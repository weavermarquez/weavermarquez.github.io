<!-- Generated from dbca41c on 2023-12-28 @ 00:37 with Emacs 27.2 (Org mode 9.4.4) -->
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta author="System Crafters - David Wilson"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="icon" type="image/png" href="/img/favicon.png"/><link rel="alternative" type="application/rss+xml" title="System Crafters News" href="https://weavermarquez.github.io/rss/news.xml"/><link rel="stylesheet" href="https://weavermarquez.github.io/fonts/iosevka-aile/iosevka-aile.css"/><link rel="stylesheet" href="https://weavermarquez.github.io/fonts/jetbrains-mono/jetbrains-mono.css"/><link rel="stylesheet" href="https://weavermarquez.github.io/css/code.css"/><link rel="stylesheet" href="https://weavermarquez.github.io/css/site.css"/><script defer="defer" data-domain="weavermarquez.github.io" src="https://plausible.io/js/plausible.js"></script><title>Managing Files and Directories in Practice - System Crafters</title></head><body><header class="site-header"><div class="container"><div class="site-title"><img class="logo" src="https://weavermarquez.github.io/img/sc_logo.png" alt="System Crafters"/></div></div><div class="site-masthead"><div class="container"><nav class="nav"><a class="nav-link" href="/">Home</a> <a class="nav-link" href="/guides/">Guides</a> <a class="nav-link" href="/news/">News</a> <a class="nav-link" href="/community/">Community</a> <a class="nav-link" href="/">Home (2)</a> <a class="nav-link" href="/how-to-help/">How to Help</a></nav></div></div></header><div class="container"><div class="site-post"><h1 class="site-post-title">Managing Files and Directories in Practice</h1><p class="site-post-meta"></p><div id="content"><p>
<div class="video">  <iframe src="https://www.youtube.com/embed/nq-gqNGmayI" allowfullscreen></iframe></div>
</p>

<h2><a id="what-will-we-cover" class="anchor" href="#what-will-we-cover">¶</a>What will we cover?</h2><div class="outline-text-2" id="text-orgb47c6fd">
<p>
Today we&rsquo;re going to talk about the many ways you can interact with files and directories using Emacs Lisp!
</p>

<p>
There are a few different ways to do this with user-facing Emacs functionality (<code>find-file</code>, <code>eshell</code>, Dired, etc), but at some point you will want to automate some of these tasks with Emacs Lisp code.
</p>

<p>
Today I&rsquo;ll show you a wide range of the functions you have at your disposal and then use them in real code examples!
</p>

<p>
The final code from this episode can be found <a href="https://github.com/daviwil/dotcrafter.el/blob/8589c71e64b60f9395b418c09b60815a86c7da8f/dotcrafter.el">on GitHub</a>.
</p>
</div>

<h3><a id="explaining-symbolic-links" class="anchor" href="#explaining-symbolic-links">¶</a>Explaining symbolic links</h3><div class="outline-text-3" id="text-org55f5697">
<p>
But first, what is a symbolic link?
</p>

<p>
It is an entry in the file system that points to a file or directory somewhere else in the file system.  It is used to make it appear like a directory exists at <code>~/.emacs.d</code> when it actually exists at <code>~/.dotfiles/.emacs.d</code>!
</p>
</div>

<h3><a id="our-project-dotcrafterel" class="anchor" href="#our-project-dotcrafterel">¶</a>Our project: dotcrafter.el</h3><div class="outline-text-3" id="text-org4f44b62">
<p>
As we talked about in previous videos in this series, we are working on a dotfiles management package for Emacs.
</p>

<p>
In this video we&rsquo;re going to add functionality to create symbolic links for your configuration files into the real locations where they belong in the home directory!
</p>

<p>
Some context:
</p>
<ul class="org-ul">
<li>We&rsquo;ve been focused on dotfiles generated from Org Mode files</li>
<li>You&rsquo;ll probably also have configuration files that don&rsquo;t belong in Org files!</li>
<li>We need a way to automatically link those configuration files into the home directory</li>
<li>We will implement code to &ldquo;mirror&rdquo; your configuration files into the home directory using symbolic links</li>
</ul>

<p>
By the end of this episode, we&rsquo;ll have a fully working dotfiles management package!
</p>

<p>
We&rsquo;ll commit improvements made in this video to the GitHub repository: <a href="https://github.com/daviwil/dotcrafter.el">https://github.com/daviwil/dotcrafter.el</a>
</p>

<p>
The starting point of the examples in this episode is <a href="https://github.com/daviwil/dotcrafter.el/blob/0374d5a1ad1e5ecadcdfbdf07e0ae428946b0138/dotcrafter.el">this version of dotcrafter.el</a> from the repository.
</p>

<div class="cta center">
If you find this guide helpful, please consider supporting System Crafters via the links on the <a href="/how-to-help/#support-my-work">How to Help</a> page!
</div>
</div>

<h2><a id="getting-the-current-directory" class="anchor" href="#getting-the-current-directory">¶</a>Getting the current directory</h2><div class="outline-text-2" id="text-orgc2b9dc2">
<p>
Emacs will resolve most file paths relative to the current directory which is determine by the variable <code>default-directory</code>.  This buffer-local variable will be different for each buffer you open.
</p>

<p>
For file buffers, it will contain the directory where the buffer&rsquo;s file lives:
</p>

<pre>default-directory</pre>

<p>
What about the <code>*scratch*</code> buffer?  It <i>probably</i> returns the directory where Emacs was launched from!
</p>

<p>
You can also change <code>default-directory</code> if necessary!
</p>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/File-Names.html">Emacs Manual: File Names</a>
</p>
</div>

<h2><a id="manipulating-file-paths" class="anchor" href="#manipulating-file-paths">¶</a>Manipulating file paths</h2><div class="outline-text-2" id="text-org4bafa8e">
<p>
When you want to automate file operations in Emacs, you&rsquo;ll often need to grab different parts of a path so that you can build new paths.  There are a few functions for this purpose!
</p>

<p>
In Emacs, file paths are considered to have two parts:
</p>

<ul class="org-ul">
<li>The directory part</li>
<li>The non-directory part, i.e. the file name and its extension</li>
</ul>

<p>
The functions you will want to use for this purpose are all prefixed with <code>file-name</code>!
</p>

<ul class="org-ul">
<li><code>file-name-directory</code>: Get the directory part of a file path</li>
<li><code>file-name-nondirectory</code>: Get the filename (non-directory) part of a file path</li>
<li><code>file-name-extension</code>: Get the extension of the file (without the leading period <code>.</code>)</li>
<li><code>file-name-sans-extension</code>: Get the path without the file extension</li>
<li><code>file-name-base</code>: Get the base file name without path or extension</li>
<li><code>file-name-as-directory</code>: Turn the file name into a directory name</li>
</ul>

<p>
NOTE: The file paths you pass to these functions do not have to exist!
</p>

<pre>(file-name-directory (buffer-file-name))

(file-name-nondirectory (buffer-file-name))

(file-name-extension (buffer-file-name))

(file-name-sans-extension (buffer-file-name))

(file-name-base (buffer-file-name))

(file-name-as-directory (buffer-file-name))

(file-name-as-directory
 (file-name-sans-extension (buffer-file-name)))</pre>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Names.html#File-Names">Emacs Lisp Manual: File Names</a>
</p>
</div>

<h2><a id="resolving-file-paths" class="anchor" href="#resolving-file-paths">¶</a>Resolving file paths</h2><div class="outline-text-2" id="text-orgb518d61">
<p>
It is a good idea to resolve file paths any time you use them to ensure they are being used for the location you expect!
</p>

<ul class="org-ul">
<li><code>file-name-absolute-p</code> will tell you whether a file name is &ldquo;absolute&rdquo;: it contains a complete file system path</li>
<li><code>file-relative-name</code> with give you the path of a file relative to another path</li>
<li><code>expand-file-name</code> will return an absolute path for a file under a specified directory</li>
</ul>

<pre>(file-name-absolute-p (buffer-file-name))      <span class="org-comment-delimiter">;; </span><span class="org-comment">t</span>
(file-name-absolute-p <span class="org-string">"Emacs-Lisp-06.org"</span>)     <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>
(file-name-absolute-p <span class="org-string">"dir/Emacs-Lisp-06.org"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>

(file-relative-name (buffer-file-name) <span class="org-string">"~/Notes"</span>)     <span class="org-comment-delimiter">;; </span><span class="org-comment">Streams/Emacs-Lisp-06.org</span>
(file-relative-name (buffer-file-name) <span class="org-string">"~/.dotfiles"</span>)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">../Notes/Streams/Emacs-Lisp-06.org</span>

(expand-file-name <span class="org-string">"Emacs-Lisp-06.org"</span>)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">/home/daviwil/Notes/Streams/Emacs-Lisp-06.org</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">The file doesn't have to exist!</span>
(expand-file-name <span class="org-string">"Emacs-Lisp-06.org"</span> <span class="org-string">"~/.dotfiles"</span>)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">/home/daviwil/.dotfiles/Emacs-Lisp-06.org</span></pre>

<p>
What about resolving paths containing environment variables?
</p>

<pre>(expand-file-name <span class="org-string">"$HOME/.emacs.d"</span>)
(substitute-in-file-name <span class="org-string">"$HOME/.emacs.d"</span>)</pre>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Relative-File-Names.html#Relative-File-Names">Emacs Lisp Manual: Absolute and Relative File Names</a>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Name-Expansion.html">Emacs Lisp Manual: Functions that Expand Filenames</a>
</p>
</div>

<h2><a id="example-resolving-the-destination-path-of-a-configuration-file" class="anchor" href="#example-resolving-the-destination-path-of-a-configuration-file">¶</a>Example: Resolving the destination path of a configuration file</h2><div class="outline-text-2" id="text-org4615586">
<p>
We can use a few of the functions we just discussed to find where a file inside of the dotfiles folder should be linked in the home directory!
</p>

<p>
Here&rsquo;s what we need to do:
</p>

<ul class="org-ul">
<li>Resolve the relative path of a file under the dotfiles folder relative to the dotfiles folder</li>
<li>Resolve that relative path against the home directory (or more specifically the output directory)</li>
</ul>

<p>
For example:
</p>

<pre>~/.dotfiles/.files/

~/.dotfiles/.files/.local/share/applications/Emacs.desktop

  Resolve to --&gt;   .local/share/applications/Emacs.desktop
  Resolve to --&gt; ~/.local/share/applications/Emacs.desktop</pre>

<p>
We&rsquo;re also going to define a variable that holds the specific subpath of the dotfiles folder where these linked configuration files should live so that they&rsquo;re easier to manage.
</p>

<pre>(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-dotfiles-folder</span> <span class="org-string">"~/.dotfiles"</span>
  <span class="org-doc">"The folder where dotfiles and org-mode configuration files are stored."</span>
  <span class="org-builtin">:type</span> 'string
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-output-directory</span> <span class="org-string">"~"</span>
  <span class="org-doc">"The directory where dotcrafter.el will write out your dotfiles.</span>
<span class="org-doc">This is typically set to the home directory but can be changed</span>
<span class="org-doc">for testing purposes."</span>
  <span class="org-builtin">:type</span> 'string
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-config-files-directory</span> <span class="org-string">".files"</span>
  <span class="org-doc">"The directory path inside of `</span><span class="org-doc"><span class="org-constant">dotcrafter-dotfiles-folder</span></span><span class="org-doc">' where</span>
<span class="org-doc">configuration files that should be symbolically linked are stored."</span>
  <span class="org-builtin">:type</span> 'string
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">setq</span> dotcrafter-dotfiles-folder <span class="org-string">"~/Projects/Code/dotcrafter.el/example"</span>)
(<span class="org-keyword">setq</span> dotcrafter-output-directory <span class="org-string">"~/Projects/Code/dotcrafter.el/demo-output"</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--resolve-config-files-path</span> ()
  (expand-file-name dotcrafter-config-files-directory
                    dotcrafter-dotfiles-folder))

(<span class="org-keyword">defun</span> <span class="org-function-name">example--resolve-config-file-target</span> (config-file)
  (expand-file-name
   (file-relative-name
    (expand-file-name config-file)
    (dotcrafter--resolve-config-files-path))
   dotcrafter-output-directory))

(example--resolve-config-file-target <span class="org-string">"~/Projects/Code/dotcrafter/example/.files/.emacs.d/init.el"</span>)</pre>
</div>

<h2><a id="checking-if-files-and-directories-exist" class="anchor" href="#checking-if-files-and-directories-exist">¶</a>Checking if files and directories exist</h2><div class="outline-text-2" id="text-org595ae84">
<p>
The <code>file-exists-p</code> function returns <code>t</code> if a file or directory exists or <code>nil</code> otherwise:
</p>

<pre>(file-exists-p <span class="org-string">"~/.dotfiles/.emacs.d"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">t</span>
(file-exists-p <span class="org-string">"~/.dotfiles/foobar"</span>)    <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span></pre>

<p>
There are a few more functions that you can use to check if the user has access to a file, whether its writable or executable, etc:
</p>

<ul class="org-ul">
<li><code>file-readable-p</code></li>
<li><code>file-executable-p</code></li>
<li><code>file-writable-p</code></li>
</ul>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Testing-Accessibility.html">Emacs Lisp Manual: Testing Accessibility</a>
</p>
</div>

<h2><a id="creating-directories" class="anchor" href="#creating-directories">¶</a>Creating directories</h2><div class="outline-text-2" id="text-org5607f45">
<p>
You can easily create a directory with the <code>make-directory</code> command.
</p>

<p>
The first parameter is the path to the directory to be created and the second is an optional boolean (<code>t</code> or <code>nil</code>) which determines whether any missing parent directories in the path should also be created.
</p>

<p>
You can also set the second parameter to <code>t</code> to ensure that <code>make-directory</code> won&rsquo;t throw an error if the directory already exists!
</p>

<pre>(make-directory <span class="org-string">"~/.local/share/foobar"</span>)
(make-directory <span class="org-string">"~/.local/share/foobar"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">throws an error</span>
(make-directory <span class="org-string">"~/.local/share/foobar"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">no error!</span>

(make-directory <span class="org-string">"~/.local/share/hello/system/crafters"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">error</span>
(make-directory <span class="org-string">"~/.local/share/hello/system/crafters"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">success!</span></pre>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Create_002fDelete-Dirs.html">Emacs Lisp Manual: Creating, Copying, and Deleting Directories</a>
</p>
</div>

<h2><a id="example-creating-expected-directories-before-linking" class="anchor" href="#example-creating-expected-directories-before-linking">¶</a>Example: Creating expected directories before linking</h2><div class="outline-text-2" id="text-org6095e27">
<p>
When we begin creating symbolic links into the home directory, one thing we will need to be careful of is creating symbolic links too close to the home directory for commonly-used folders like <code>~/.config</code> or <code>~/.local/share</code>.
</p>

<p>
What we want to avoid is creating a symlink for these folders to our dotfiles folder and then having a bunch of unwanted files show up there that we must add to our <code>.gitignore</code>!
</p>

<p>
The solution here is to make sure that these directories already exist so that the algorithm we will write later won&rsquo;t try to create symbolic links instead.  To accomplish this, we will create a new variable to hold the list of directories to be pre-created and then create those directories before we start the linking process:
</p>

<pre>(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-ensure-output-directories</span> '(<span class="org-string">".config"</span> <span class="org-string">".local/share"</span>)
  <span class="org-doc">"List of directories in the output folder that should be created</span>
<span class="org-doc">before linking configuration files."</span>
  <span class="org-builtin">:type</span>  '(list string)
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">defun</span> <span class="org-function-name">example--ensure-output-directories</span> ()
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Ensure that the expected output directories are already</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">created so that links will be created inside</span>
  (<span class="org-keyword">dolist</span> (dir dotcrafter-ensure-output-directories)
    (make-directory (expand-file-name dir dotcrafter-output-directory) t)))

(example--ensure-output-directories)</pre>
</div>

<h2><a id="listing-files-in-directories" class="anchor" href="#listing-files-in-directories">¶</a>Listing files in directories</h2><div class="outline-text-2" id="text-org828a419">
<p>
One thing you will probably want to do at some point is get a list of files in a given directory, possibly even for all child directories under that path as well.
</p>

<p>
The <code>directory-files</code> and <code>directory-files-recursively</code> functions are great for this purpose!
</p>

<pre>(directory-files <span class="org-string">"~/.dotfiles"</span>)
(directory-files <span class="org-string">"~/.dotfiles"</span> t)          <span class="org-comment-delimiter">;; </span><span class="org-comment">Return full file paths</span>
(directory-files <span class="org-string">"~/.dotfiles"</span> t <span class="org-string">".org"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Get all file containing ".org"</span>
(directory-files <span class="org-string">"~/.dotfiles"</span> t <span class="org-string">""</span> t)     <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't sort results</span>
(directory-files <span class="org-string">"~/.dotfiles"</span> t <span class="org-string">""</span> nil 3) <span class="org-comment-delimiter">;; </span><span class="org-comment">Maximum 3 results</span>

(directory-files-recursively <span class="org-string">"~/.dotfiles"</span> <span class="org-string">"\\.el$"</span>)
(directory-files-recursively dotcrafter-output-directory <span class="org-string">""</span>)
(directory-files-recursively dotcrafter-output-directory <span class="org-string">""</span> t)

<span class="org-comment-delimiter">;; </span><span class="org-comment">The fourth parameter can be a function that determines whether</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">a path can be traversed using any logic!</span>
(directory-files-recursively <span class="org-string">"~/.emacs.d"</span> <span class="org-string">""</span> nil
                             (<span class="org-keyword">lambda</span> (dir)
                               (string-equal dir <span class="org-string">"~/.emacs.d/lisp"</span>)))

(directory-files-recursively <span class="org-string">"~/.config"</span> <span class="org-string">"\\.scm"</span> t nil nil) <span class="org-comment-delimiter">;; </span><span class="org-comment">Doesn't follow symlinks</span>
(directory-files-recursively <span class="org-string">"~/.config"</span> <span class="org-string">"\\.scm"</span> t nil t)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Follows symlinks!</span></pre>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Contents-of-Directories.html#Contents-of-Directories">Emacs Lisp Manual: Contents of Directories</a>
</p>
</div>

<h2><a id="example-finding-the-list-of-all-configuration-files-to-be-linked" class="anchor" href="#example-finding-the-list-of-all-configuration-files-to-be-linked">¶</a>Example: Finding the list of all configuration files to be linked</h2><div class="outline-text-2" id="text-org225ae5d">
<p>
As we talked about earlier, the goal of what we&rsquo;re doing today is to produce some code that will mirror a folder of configuration files in your dotfiles folder into the home folder using symbolic links.
</p>

<p>
We&rsquo;ll use the <code>directory-files-recursively</code> function to list all of the linkable files under the dotfiles path and then resolve them relative to the output path!
</p>

<pre>(<span class="org-keyword">defun</span> <span class="org-function-name">example--find-all-files-to-link</span> ()
  (<span class="org-keyword">let</span> ((files-to-link
         (directory-files-recursively
          (dotcrafter--resolve-config-files-path)
          <span class="org-string">""</span>)))
    (<span class="org-keyword">dolist</span> (file files-to-link)
      (message <span class="org-string">"File: %s\n   - %s"</span> file (example--resolve-config-file-target file)))))

(example--find-all-files-to-link)</pre>
</div>

<h2><a id="copying-moving-and-deleting-files-and-directories" class="anchor" href="#copying-moving-and-deleting-files-and-directories">¶</a>Copying, moving, and deleting files and directories</h2><div class="outline-text-2" id="text-orgb756a4d">
<p>
You can perform common file management tasks like copying, moving, and deleting files and directories with a few different Emacs Lisp functions.
</p>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Copying-and-Naming.html">Emacs Lisp Manual: Copying, Naming, and Renaming Files</a>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Create_002fDelete-Dirs.html">Emacs Lisp Manual: Creating, Copying, and Deleting Directories</a>
</p>
</div>

<h3><a id="copying" class="anchor" href="#copying">¶</a>Copying</h3><div class="outline-text-3" id="text-org9049818">
<ul class="org-ul">
<li><code>copy-file</code>: Copy the contents of one file to another</li>
<li><code>copy-directory</code>: Copy the contents of one directory to another, including all subdirectories</li>
</ul>

<pre>(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">Must end in a slash!</span>
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp/"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied to /tmp</span>
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp/"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Error, already exists!</span>
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp/"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">No error!</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">The remaining parameters are all about preserving file metadata</span>

(copy-directory <span class="org-string">"~/.emacs.d/lisp"</span> <span class="org-string">"/tmp"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">Must end in a slash!</span>
(copy-directory <span class="org-string">"~/.emacs.d/lisp"</span> <span class="org-string">"/tmp/"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied to /tmp/lisp</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">To copy the contents of the directory without the enclosing directory:</span>
(copy-directory <span class="org-string">"~/.emacs.d/eshell"</span> <span class="org-string">"/tmp/lisp"</span> t t nil)
(copy-directory <span class="org-string">"~/.emacs.d/eshell"</span> <span class="org-string">"/tmp/lisp"</span> t t t)</pre>
</div>

<h3><a id="renaming--moving" class="anchor" href="#renaming--moving">¶</a>Renaming / Moving</h3><div class="outline-text-3" id="text-org012f6f7">
<ul class="org-ul">
<li><code>rename-file</code>: Rename a file or directory</li>
</ul>

<pre>(rename-file <span class="org-string">"/tmp/init.el"</span> <span class="org-string">"/tmp/init-new.el"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">Rename file in same folder</span>
(rename-file <span class="org-string">"/tmp/init-new.el"</span> <span class="org-string">"~/.emacs.d/"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">Move file to different folder</span>
(rename-file <span class="org-string">"~/.emacs.d/init-new.el"</span> <span class="org-string">"~/.emacs.d/init.el"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Error!</span>
(rename-file <span class="org-string">"~/.emacs.d/init-new.el"</span> <span class="org-string">"~/.emacs.d/init.el"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">OK</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">It can also rename or move directories!</span>
(rename-file <span class="org-string">"/tmp/lisp"</span> <span class="org-string">"/tmp/lisp-two"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">OK</span>
(rename-file <span class="org-string">"/tmp/lisp-two"</span> <span class="org-string">"/tmp/lisp"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">OK</span></pre>
</div>

<h3><a id="deleting" class="anchor" href="#deleting">¶</a>Deleting</h3><div class="outline-text-3" id="text-orgeeef2e7">
<ul class="org-ul">
<li><code>delete-file</code>: Delete a file, optionally moving it to the trash folder</li>
<li><code>delete-directory</code>: Deletes a directory, including files if desired</li>
</ul>

<pre>(delete-file <span class="org-string">"/tmp/lisp/dw-desktop.el"</span>)
(delete-file <span class="org-string">"~/.npmrc"</span> t)

(delete-directory <span class="org-string">"/tmp/lisp"</span>)
(delete-directory <span class="org-string">"/tmp/lisp"</span> t)</pre>
</div>

<h2><a id="example-migrating-configuration-files-to-the-dotfiles-folder" class="anchor" href="#example-migrating-configuration-files-to-the-dotfiles-folder">¶</a>Example: Migrating configuration files to the dotfiles folder</h2><div class="outline-text-2" id="text-org649ca92">
<p>
As we continue building our configurations, it&rsquo;s likely that we&rsquo;ll want to migrate a configuration folder into our dotfiles repository.  Let&rsquo;s define a function that will make this really easy for the user:
</p>

<ul class="org-ul">
<li>The user chooses a folder to move into their dotfiles configuration</li>
<li>We ensure that the chosen file is located under the home directory (<code>dotcrafter-output-directory</code>)</li>
<li>If so, move the file to the corresponding location under the config path</li>
</ul>

<pre><span class="org-comment-delimiter">;; </span><span class="org-comment">Run this to feed the demo!</span>
(copy-directory <span class="org-string">"~/.dotfiles/.config/guix"</span>
                (file-name-as-directory (expand-file-name <span class="org-string">".config"</span>
                                                          dotcrafter-output-directory)))
(copy-file <span class="org-string">"~/.dotfiles/.bash_profile"</span>
           (file-name-as-directory dotcrafter-output-directory))

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter-move-to-config-files</span> (source-path)
  <span class="org-doc">"Move a file from the output path to the configuration path."</span>
  (<span class="org-keyword">interactive</span> <span class="org-string">"FConfiguration path to move: "</span>)
  (<span class="org-keyword">let*</span> ((relative-path (file-relative-name (expand-file-name source-path)
                                            dotcrafter-output-directory))
         (dest-path (expand-file-name relative-path
                                      (dotcrafter--resolve-config-files-path)))
         <span class="org-comment-delimiter">;; </span><span class="org-comment">Strip any trailing slash so that we can treat the directory as file</span>
         (dest-path (<span class="org-keyword">if</span> (string-suffix-p <span class="org-string">"/"</span> dest-path)
                        (substring dest-path 0 -1)
                      dest-path)))
         <span class="org-comment-delimiter">;; </span><span class="org-comment">Make sure that the path is under the output directory and that it</span>
         <span class="org-comment-delimiter">;; </span><span class="org-comment">doesn't already exist</span>
         (<span class="org-keyword">when</span> (string-prefix-p <span class="org-string">".."</span> relative-path)
           (<span class="org-warning">error</span> <span class="org-string">"Copied path is not inside of config output directory: %s"</span> dotcrafter-output-directory))
         (<span class="org-keyword">when</span> (file-exists-p dest-path)
           (<span class="org-warning">error</span> <span class="org-string">"Can't copy path because it already exists in the configuration directory: %s"</span> dest-path))

         <span class="org-comment-delimiter">;; </span><span class="org-comment">Ensure that parent directories exist and then move the file!</span>
         (make-directory (file-name-directory dest-path) t)
         (rename-file source-path dest-path)))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">TODO: Link this path back into the dotcrafter-output-directory</span></pre>
</div>

<h2><a id="creating-symbolic-links" class="anchor" href="#creating-symbolic-links">¶</a>Creating symbolic links</h2><div class="outline-text-2" id="text-org7ce90ed">
<p>
Using symbolic links, we&rsquo;re able to keep our configuration files in a local Git repository and then make them appear in our home folder.
</p>

<p>
Creating symbolic links is very easy in Emacs with the <code>make-symbolic-link</code> function:
</p>

<pre>(make-symbolic-link <span class="org-string">"~/.dotfiles/.config/guix"</span> <span class="org-string">"~/.config/guix"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Error if exists</span>
(make-symbolic-link <span class="org-string">"~/.dotfiles/.config/guix"</span> <span class="org-string">"~/.config/guix"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">No error!</span></pre>

<p>
However, this doesn&rsquo;t work exactly the same on Windows!  You might need to run Emacs with elevation for it to work.
</p>

<p>
You can also check if a file is a symbolic link using <code>file-symlink-p</code> and get the path it points to using <code>file-truename</code>:
</p>

<pre>(file-symlink-p <span class="org-string">"~/.emacs.d"</span>)         <span class="org-comment-delimiter">;; </span><span class="org-comment">.dotfiles/.emacs.d</span>
(file-symlink-p <span class="org-string">"~/.emacs.d/init.el"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>
(file-truename <span class="org-string">"~/.emacs.d/init.el"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">/home/daviwil/.dotfiles/.emacs.d/init.el</span></pre>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Copying-and-Naming.html">Emacs Lisp Manual: Copying, Naming, and Renaming Files</a>
</p>
</div>

<h2><a id="example-creating-symbolic-links-for-all-configuration-files" class="anchor" href="#example-creating-symbolic-links-for-all-configuration-files">¶</a>Example: Creating symbolic links for all configuration files</h2><div class="outline-text-2" id="text-orgc280ff2">
<p>
Here&rsquo;s where everything in this episode finally comes together!
</p>

<p>
We&rsquo;re going to implement a more elaborate algorithm that will create symbolic links at the optimal level in the home directory so that we don&rsquo;t need to create a link for every single file.
</p>

<p>
If you&rsquo;ve ever used GNU Stow, this will look pretty familiar!
</p>
</div>

<h3><a id="the-process" class="anchor" href="#the-process">¶</a>The Process</h3><div class="outline-text-3" id="text-orga94d596">
<p>
This is what we&rsquo;ll do:
</p>

<ul class="org-ul">
<li>Loop over all files in <code>dotcrafter-config-files-directory</code></li>
<li>For each file, break the path into pieces for each directory up to the filename</li>
<li>For each piece of the file&rsquo;s path, check if the folder exists</li>
<li>If it exists, check if it&rsquo;s a symbolic link that points to the matching directory in the config folder</li>
<li>If it doesn&rsquo;t exist, create the symlink there</li>
</ul>

<p>
Here&rsquo;s a clearer depicton of what this means:
</p>

<pre>~/.dotfiles/.files/.local/share/applications/Emacs.desktop
                 ~/.local/share/applications/Emacs.desktop
                  L .local exists? YES
                         L share exists? YES
                               L applications exists? NO, create link!</pre>
</div>

<h3><a id="the-code" class="anchor" href="#the-code">¶</a>The Code</h3><div class="outline-text-3" id="text-org93f8be8">
<p>
Let&rsquo;s walk through the code line by line before running it!
</p>

<ul class="org-ul">
<li><code>dotcrafter-link-config-files</code>: The user-facing function that links the whole config directory</li>
<li><code>dotcrafter-link-config-file</code>: The &ldquo;internal&rdquo; function that handles linking a single file</li>
</ul>

<pre>(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--link-config-file</span> (config-file)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Get the "path parts", basically the name of each directory and file in the</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">path of config-file</span>
  (<span class="org-keyword">let*</span> ((path-parts
          (split-string (file-relative-name (expand-file-name config-file)
                                            (dotcrafter--resolve-config-files-path))
                        <span class="org-string">"/"</span> t))
         (current-path nil))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Check each "part" of the path to find the right place to create the symlink.</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Whenever path-parts is nil, stop looping!</span>
    (<span class="org-keyword">while</span> path-parts
      <span class="org-comment-delimiter">;; </span><span class="org-comment">Create the current path using the first part and remove it from the</span>
      <span class="org-comment-delimiter">;; </span><span class="org-comment">front of the list for future iterations</span>
      (<span class="org-keyword">setq</span> current-path (<span class="org-keyword">if</span> current-path
                             (concat current-path <span class="org-string">"/"</span> (car path-parts))
                           (car path-parts)))
      (<span class="org-keyword">setq</span> path-parts (cdr path-parts))

      <span class="org-comment-delimiter">;; </span><span class="org-comment">Figure out whether the current source path can be linked to the target path</span>
      (<span class="org-keyword">let</span> ((source-path (expand-file-name (concat dotcrafter-config-files-directory <span class="org-string">"/"</span> current-path)
                                           dotcrafter-dotfiles-folder))
            (target-path (expand-file-name current-path dotcrafter-output-directory)))
        <span class="org-comment-delimiter">;; </span><span class="org-comment">If the file or directory exists, is it a symbolic link?</span>
        (<span class="org-keyword">if</span> (file-symlink-p target-path)
            <span class="org-comment-delimiter">;; </span><span class="org-comment">If the symbolic link exists, does it point to the source-path?</span>
            (<span class="org-keyword">if</span> (string-equal source-path (file-truename target-path))
                <span class="org-comment-delimiter">;; </span><span class="org-comment">Clear path-parts to stop looping</span>
                (<span class="org-keyword">setq</span> path-parts '())
              (<span class="org-warning">error</span> <span class="org-string">"Path already exists with different symlink! %s"</span> target-path))
          <span class="org-comment-delimiter">;; </span><span class="org-comment">If the target path is an existing directory, we need to keep</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">looping, otherwise we can create a symlink here!</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">Otherwise, the file is probably a directory so keep looping</span>
          (<span class="org-keyword">when</span> (not (file-directory-p target-path))
            <span class="org-comment-delimiter">;; </span><span class="org-comment">Create a symbolic link to the source-path and</span>
            <span class="org-comment-delimiter">;; </span><span class="org-comment">clear the path-parts so that we stop looping</span>
            (make-symbolic-link source-path target-path)
            (<span class="org-keyword">setq</span> path-parts '())))))))

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter-link-config-files</span> ()
  (<span class="org-keyword">interactive</span>)
  (<span class="org-keyword">let</span> ((config-files
         (directory-files-recursively
          (dotcrafter--resolve-config-files-path)
          <span class="org-string">""</span>)))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Ensure that the expected output directories are already</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">created so that links will be created inside</span>
    (<span class="org-keyword">dolist</span> (dir dotcrafter-ensure-output-directories)
      (make-directory (expand-file-name dir dotcrafter-output-directory) t))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">Link all of the source config files to the output path</span>
    (<span class="org-keyword">dolist</span> (file config-files)
      (dotcrafter--link-config-file file))))</pre>
</div>

<h2><a id="the-final-code-in-action" class="anchor" href="#the-final-code-in-action">¶</a>The final code in action</h2><div class="outline-text-2" id="text-orge4d52cd">
<p>
One last piece will bring together everything we&rsquo;ve done in the past few episodes is this function:
</p>

<pre>(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter-update-dotfiles</span> ()
  <span class="org-doc">"Generate and link configuration files to the output directory.</span>

<span class="org-doc">This command handles the full process of \"tangling\" Org Mode</span>
<span class="org-doc">files containing configuration blocks and creating symbolic links</span>
<span class="org-doc">to those configuration files in the output directory, typically</span>
<span class="org-doc">the user's home directory."</span>
  (<span class="org-keyword">interactive</span>)
  (dotcrafter-tangle-org-files)
  (dotcrafter-link-config-files)
  (dotcrafter--update-gitignore))</pre>

<p>
This will tangle all of our Org configuration files, link all output files to the home directory, and update the <code>.gitignore</code> to ignore any of the generated files in the repo.
</p>

<p>
Let&rsquo;s try it all out!
</p>

<pre>emacs -Q --batch -l demo.el</pre>

<p>
We can also run this function multiple times and it will work just fine!
</p>
</div>

<h2><a id="whatrsquos-next" class="anchor" href="#whatrsquos-next">¶</a>What&rsquo;s next?</h2><div class="outline-text-2" id="text-orgd4872ba">
<p>
Now that we&rsquo;ve got a functioning package, it&rsquo;s time to take things to the next level by creating major and minor modes for it!
</p>

<p>
In the next episode, I&rsquo;ll show you how to create a minor mode to gracefully handle automatic Org file tangling.
</p>

<p>
In the following episodes, we&rsquo;ll create a major mode that provides a user interface for the package and then start polishing it up to be published on MELPA!
</p>
</div>
</div></div><div class="list-form center"><div class="list-form-title">Subscribe to the System Crafters Newsletter!</div><form method="POST" action="https://www.simplelists.com/subscribe.php"><input type="hidden" name="format" value="text"/><input type="hidden" name="action" value="subscribe"/><input type="hidden" name="list" value="news@lists.systemcrafters.net"/><div class="list-form-message">Stay up to date with the latest System Crafters news and updates!  Read the <a href="/newsletter/">Newsletter</a> page for more information.</div><div class="row"><div class="column"><div class="row center list-form-label">Name (optional)</div><div class="row"><input type="text" name="name"/></div></div><div class="column"><div class="row center list-form-label">Email Address</div><div class="row"><input type="text" name="email"/></div></div></div><div><input type="submit" value="Subscribe!"/></div></form></div></div><footer class="site-footer"><div class="container"><div class="row"><div class="column"><p><a href="https://weavermarquez.github.io/privacy-policy/">Privacy Policy</a> · <a href="https://weavermarquez.github.io/credits/">Credits</a> · <a href="https://weavermarquez.github.io/rss/">RSS Feeds</a> · <a rel="me" href="https://fosstodon.org/@daviwil">Fediverse</a></p><p>© 2021-2023 System Crafters LLC, and also Weaver Ripped this off</p></div><div class="column align-right"><p><a href="https://github.com/weavermarquez/weavermarquez.github.io"><img src="https://weavermarquez.github.io/img/codeberg.png" style="width: 120px" alt="Contribute on Codeberg"/></a></p></div></div></div></footer></body></html>
