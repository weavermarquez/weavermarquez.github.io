<!-- Generated from dbca41c on 2023-12-28 @ 00:37 with Emacs 27.2 (Org mode 9.4.4) -->
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta author="System Crafters - David Wilson"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="icon" type="image/png" href="/img/favicon.png"/><link rel="alternative" type="application/rss+xml" title="System Crafters News" href="https://weavermarquez.github.io/rss/news.xml"/><link rel="stylesheet" href="https://weavermarquez.github.io/fonts/iosevka-aile/iosevka-aile.css"/><link rel="stylesheet" href="https://weavermarquez.github.io/fonts/jetbrains-mono/jetbrains-mono.css"/><link rel="stylesheet" href="https://weavermarquez.github.io/css/code.css"/><link rel="stylesheet" href="https://weavermarquez.github.io/css/site.css"/><script defer="defer" data-domain="weavermarquez.github.io" src="https://plausible.io/js/plausible.js"></script><title>Reading and Writing Buffers In Practice - System Crafters</title></head><body><header class="site-header"><div class="container"><div class="site-title"><img class="logo" src="https://weavermarquez.github.io/img/sc_logo.png" alt="System Crafters"/></div></div><div class="site-masthead"><div class="container"><nav class="nav"><a class="nav-link" href="/">Home</a> <a class="nav-link" href="/guides/">Guides</a> <a class="nav-link" href="/news/">News</a> <a class="nav-link" href="/community/">Community</a> <a class="nav-link" href="/">Home (2)</a> <a class="nav-link" href="/how-to-help/">How to Help</a></nav></div></div></header><div class="container"><div class="site-post"><h1 class="site-post-title">Reading and Writing Buffers In Practice</h1><p class="site-post-meta"></p><div id="content"><p>
<div class="video">  <iframe src="https://www.youtube.com/embed/J7d2LmivyyM" allowfullscreen></iframe></div>
</p>

<h2><a id="why-learn-about-buffers" class="anchor" href="#why-learn-about-buffers">¶</a>Why learn about buffers?</h2><div class="outline-text-2" id="text-org70db233">
<p>
You may think buffers are just for editing text files, but you can wield Emacs Lisp to do so much more:
</p>

<ul class="org-ul">
<li>Automate the editing (or creation) of files</li>
<li>Create a custom display of information for a major mode</li>
<li>Communicate with external programs</li>
<li>Provide interactive interfaces like REPLs and more</li>
</ul>

<p>
In Emacs, buffers are the primary user interface, so they&rsquo;re really important!
</p>

<div class="cta center">
If you find this guide helpful, please consider supporting System Crafters via the links on the <a href="/how-to-help/#support-my-work">How to Help</a> page!
</div>
</div>

<h2><a id="what-will-we-learn" class="anchor" href="#what-will-we-learn">¶</a>What will we learn?</h2><div class="outline-text-2" id="text-org7fcfaba">
<p>
In this episode we&rsquo;re going to focus on the basic APIs for Emacs buffers and then show how to read and edit buffer contents.
</p>

<p>
We&rsquo;re going to use a concrete example as the basis for everything we learn!
</p>
</div>

<h3><a id="our-project-dotcrafterel" class="anchor" href="#our-project-dotcrafterel">¶</a>Our project: dotcrafter.el</h3><div class="outline-text-3" id="text-orgdb76700">
<p>
As we talked about in previous videos in this series, we are working on a dotfiles management package for Emacs.
</p>

<p>
I created a repo for it!  <a href="https://github.com/daviwil/dotcrafter.el">https://github.com/daviwil/dotcrafter.el</a>.  Check it out and give it a star!
</p>

<p>
In this video, we&rsquo;ll update our dotfiles management package code to add the following capabilities:
</p>

<ul class="org-ul">
<li>Automatically detect tangled configuration output files from our Org Mode files</li>
<li>Update the dotfiles repository&rsquo;s <code>.gitignore</code> file to add the tangled output files so that they don&rsquo;t get checked in</li>
</ul>
</div>

<h3><a id="why" class="anchor" href="#why">¶</a>Why?</h3><div class="outline-text-3" id="text-orga79dcc9">
<p>
The goal of this package is to manage configuration files that are generated from Org Mode code blocks.
</p>

<p>
The pattern is to generate these files into the dotfiles folder and then symbolically link them into your home directory.
</p>

<p>
We might not want to check in those files since we will have to keep them in sync!  Instead, we add them to <code>.gitignore</code> in the dotfiles repo.
</p>

<p>
The code we will write today will automatically update the <code>.gitignore</code> file with the generated configuration file paths.
</p>
</div>

<h2><a id="what-is-a-buffer" class="anchor" href="#what-is-a-buffer">¶</a>What is a buffer?</h2><div class="outline-text-2" id="text-orgfdfe940">
<p>
In Emacs Lisp, a buffer is an object that contains text to be displayed, edited, or manipulated.  The content of buffer may not come from a file, it could be generated from within Emacs!
</p>

<p>
The text isn&rsquo;t just plain letters, it can also contain additional properties that control font, color, size, and other factors!
</p>

<p>
In Emacs, a buffer is usually displayed by a window, but you can also work with buffers without displaying them.
</p>

<p>
As we learned in the video about variables, a buffer can have it&rsquo;s own set of variables!
</p>
</div>

<h2><a id="getting-the-ldquocurrentrdquo-buffer" class="anchor" href="#getting-the-ldquocurrentrdquo-buffer">¶</a>Getting the &ldquo;current&rdquo; buffer</h2><div class="outline-text-2" id="text-orgfbc25ea">
<p>
Emacs&rsquo; buffer manipulation functions work on the current buffer.
</p>

<p>
In Emacs Lisp, you can get the current buffer with the aptly-named <code>current-buffer</code> function:
</p>

<pre>(current-buffer)</pre>

<p>
The current buffer in this case is not necessarily the one visible in the selected window!
</p>
</div>

<h2><a id="getting-a-buffer-by-name" class="anchor" href="#getting-a-buffer-by-name">¶</a>Getting a buffer by name</h2><div class="outline-text-2" id="text-org71b38dc">
<p>
If you want to retrieve a buffer by its name, use <code>get-buffer</code>:
</p>

<pre>(get-buffer <span class="org-string">"*scratch*"</span>)</pre>

<p>
You can also create the buffer if it doesn&rsquo;t already exist with <code>get-buffer-create</code>:
</p>

<pre>(get-buffer-create <span class="org-string">"Hello System Crafters!"</span>)</pre>

<p>
You can now see this in the buffer list!
</p>
</div>

<h2><a id="changing-the-current-buffer" class="anchor" href="#changing-the-current-buffer">¶</a>Changing the current buffer</h2><div class="outline-text-2" id="text-org4466245">
<p>
You can change the current buffer with <code>set-buffer</code>.  This allows you to set the current buffer that the buffer manipulation functions will operate on:
</p>

<pre>(<span class="org-keyword">progn</span>
  (set-buffer (get-buffer <span class="org-string">"*scratch*"</span>))
  (current-buffer))

<span class="org-comment-delimiter">;; </span><span class="org-comment">You can also pass the name of the buffer directly</span>
(<span class="org-keyword">progn</span>
  (set-buffer <span class="org-string">"*scratch*"</span>)
  (current-buffer))</pre>
</div>

<h2><a id="changing-the-current-buffer-safely" class="anchor" href="#changing-the-current-buffer-safely">¶</a>Changing the current buffer safely!</h2><div class="outline-text-2" id="text-orgee0e134">
<p>
However, this sets the current buffer until the current command in the command loop is finished, so it might affect other code that runs after yours!
</p>

<p>
You can avoid causing trouble by wrapping your buffer-setting code in the <code>save-current-buffer</code> form:
</p>

<pre>(<span class="org-keyword">progn</span>
  (<span class="org-keyword">save-current-buffer</span>
    (set-buffer <span class="org-string">"*scratch*"</span>)
    (message <span class="org-string">"Current buffer: %s"</span> (current-buffer)))
  (current-buffer))</pre>

<p>
For an even shorter solution, you can use the <code>with-current-buffer</code> macro:
</p>

<pre>(<span class="org-keyword">progn</span>
  (<span class="org-keyword">with-current-buffer</span> <span class="org-string">"*scratch*"</span>
    (message <span class="org-string">"Current buffer: %s"</span> (current-buffer)))
  (current-buffer))</pre>

<p>
If you use <code>set-buffer</code> in your code, you almost always want to use <code>save-current-buffer</code> or <code>with-current-buffer</code> so that you don&rsquo;t cause weird things to happen in Emacs!  These functions also handle errors correctly and ensure that the previous buffer is set back to what it was before you changed it.
</p>
</div>

<h2><a id="working-with-file-buffers" class="anchor" href="#working-with-file-buffers">¶</a>Working with file buffers</h2><div class="outline-text-2" id="text-orgdf2ea01">
<p>
Most often in Emacs, you&rsquo;ll be working with buffers that contain text loaded from a file.  If Emacs created the buffer (using <code>find-file</code> or a similar function), you can use the <code>buffer-file-name</code> function to get full file path for the file that the buffer represents:
</p>

<pre>(buffer-file-name)</pre>

<p>
You can also find a buffer that represents a particular file (or file path) using the <code>get-file-buffer</code> function:
</p>

<pre>(get-file-buffer <span class="org-string">"Emacs-Lisp-04.org"</span>)
(get-file-buffer <span class="org-string">"~/Notes/Streams/Emacs-Lisp-05.org"</span>)
(get-file-buffer <span class="org-string">"~/Notes2/Streams/Emacs-Lisp-05.org"</span>)</pre>

<p>
<b>NOTE:</b> This function will convert the path you provide into its absolute file path before searching for it.  Path expansion takes the <code>default-directory</code> variable into account, so make sure to provide as much path context as you can to make sure the right file is found!
</p>
</div>

<h2><a id="example-getting-the-buffers-for-our-configuration-org-files" class="anchor" href="#example-getting-the-buffers-for-our-configuration-org-files">¶</a>Example: Getting the buffers for our configuration Org files</h2><div class="outline-text-2" id="text-orgd6ac931">
<pre>(<span class="org-keyword">setq</span> dotcrafter-org-files '(<span class="org-string">"Emacs.org"</span> <span class="org-string">"Desktop.org"</span> <span class="org-string">"Systems.org"</span>))

(<span class="org-keyword">dolist</span> (org-file dotcrafter-org-files)
  (<span class="org-keyword">with-current-buffer</span> (get-file-buffer (expand-file-name org-file
                                                          dotcrafter-dotfiles-folder))
    (message <span class="org-string">"File: %s"</span> (buffer-file-name))))</pre>
</div>

<h2><a id="loading-a-file-into-a-buffer" class="anchor" href="#loading-a-file-into-a-buffer">¶</a>Loading a file into a buffer</h2><div class="outline-text-2" id="text-org6e346d6">
<p>
Emacs provides a function for &ldquo;visiting&rdquo; a file without displaying it, mainly for opening a file into a buffer.  This function is called <code>find-file-noselect</code>:
</p>

<pre>(find-file-noselect <span class="org-string">"Emacs-Lisp-01.org"</span>)</pre>

<p>
A couple of interesting details:
</p>

<ul class="org-ul">
<li>Running this more than once for the same file will return the same buffer</li>
<li>If the buffer for that file is modified and not saved, the user <b>might</b> be prompted before opening a new buffer for the file</li>
<li>To prevent the user from being prompted, send <code>t</code> as the second argument:</li>
</ul>

<pre>(find-file-noselect <span class="org-string">"Emacs-Lisp-01.org"</span> t)</pre>
</div>

<h2><a id="example-getting-or-creating-the-org-file-buffer" class="anchor" href="#example-getting-or-creating-the-org-file-buffer">¶</a>Example: Getting or creating the Org file buffer</h2><div class="outline-text-2" id="text-org4f3986e">
<p>
We can use <code>find-file-noselect</code> to create a buffer for the file if it doesn&rsquo;t already exist:
</p>

<pre>(<span class="org-keyword">dolist</span> (org-file dotcrafter-org-files)
  (<span class="org-keyword">let</span> ((file-path (expand-file-name org-file
                                     dotcrafter-dotfiles-folder)))
    (<span class="org-keyword">with-current-buffer</span> (<span class="org-keyword">or</span> (get-file-buffer file-path)
                             (find-file-noselect file-path))
      (message <span class="org-string">"File: %s"</span> (buffer-file-name)))))</pre>
</div>

<h2><a id="whatrsquos-the-point" class="anchor" href="#whatrsquos-the-point">¶</a>What&rsquo;s the point?</h2><div class="outline-text-2" id="text-org55e2657">
<p>
The point of talking about all of this is so that we can talk about the point!
</p>

<p>
The &ldquo;point&rdquo; is the location of the cursor in the buffer.  It is the location from which all hand editing commands operate.
</p>

<p>
The point is represented by an integer (whole number) which starts at 1 and increases for every character in the buffer.
</p>

<pre>(point)</pre>

<p>
<b>NOTE:</b> The same buffer can be displayed in multiple windows and the point can be different in those two windows!
</p>

<p>
You can also check the minimum and maximum point locations of the buffer using <code>point-min</code> and <code>point-max</code>:
</p>

<pre>(point-min)
(point-max)</pre>

<p>
&ldquo;Narrowing&rdquo; may affect these positions, but we&rsquo;ll talk about that another time.
</p>
</div>

<h2><a id="moving-the-point" class="anchor" href="#moving-the-point">¶</a>Moving the point</h2><div class="outline-text-2" id="text-orgf70c485">
<p>
You can use the following motion commands to move the point:
</p>

<ul class="org-ul">
<li><code>goto-char</code> - Move the point to a specific position (integer)</li>
<li><code>forward-char</code> - Move the point forward by a number of positions (1 by default)</li>
<li><code>backward-char</code> - Move the point backward by a number of positions (1 by default)</li>
<li><code>beginning-of-buffer</code> - Go to the beginning of the buffer</li>
<li><code>end-of-buffer</code> - Go to the end of the buffer</li>
</ul>

<p>
You can also move based on larger textual units in the buffer:
</p>

<ul class="org-ul">
<li><code>forward-word</code> - Move forward by one &ldquo;word&rdquo;</li>
<li><code>backward-word</code> - Move backward by one &ldquo;word&rdquo;</li>
</ul>

<pre>(goto-char 1)
(goto-char (point-min))
(goto-char (point-max))
(beginning-of-buffer)
(end-of-buffer)

(forward-char)
(forward-char 5)

(backward-char)
(backward-char 10)

(forward-word)
(backward-word)</pre>

<p>
There are many more <code>forward</code> and <code>backward</code> functions, just check the function list (<code>describe-function</code>, <code>C-h f</code>) to find them!
</p>

<p>
The cool thing about these functions is that they&rsquo;re the same ones you use with Emacs default movement keybindings.  You can automate buffer editing with the same functions you use for typing!
</p>
</div>

<h2><a id="preserving-the-point" class="anchor" href="#preserving-the-point">¶</a>Preserving the point</h2><div class="outline-text-2" id="text-orga207f0f">
<p>
Similarly to setting the current buffer, you might want to preserve the current point location in a buffer before you move it for another purpose.  You can use the <code>save-excursion</code> special form for this purpose:
</p>

<pre>(<span class="org-keyword">save-excursion</span>
  (goto-char (point-max))
  (point))</pre>

<p>
This is useful when you need to do an operation in the current buffer which might be displayed in the user&rsquo;s current window!
</p>
</div>

<h2><a id="examining-buffer-text" class="anchor" href="#examining-buffer-text">¶</a>Examining buffer text</h2><div class="outline-text-2" id="text-org1bbc56b">
<p>
Now that we understand the point, we can talk about how to look at text in the buffer.  The simplest thing you can do is read the character at a location with <code>char-after</code>:
</p>

<pre>(char-after)
(char-after (point))
(char-after (point-min))</pre>

<p>
You can also get a substring of text in the buffer between two points using <code>buffer-substring</code> and <code>buffer-substring-no-properties</code>:
</p>

<pre>(buffer-substring 9328 9349)
(buffer-substring-no-properties 9328 9349)</pre>
</div>

<h2><a id="the-thing" class="anchor" href="#the-thing">¶</a>The Thing</h2><div class="outline-text-2" id="text-orgd520c43">
<p>
The <code>thing-at-point</code> function is very useful for grabbing the text at the point if it matches a particular type of &ldquo;thing&rdquo;:
</p>

<ul class="org-ul">
<li><code>word</code>, <code>sentence</code>, and <code>line</code></li>
<li><code>sexp</code>, <code>list</code>, and <code>defun</code> - Lisp expressions</li>
<li><code>url</code>, <code>email</code></li>
<li><code>filename</code></li>
</ul>

<pre>(thing-at-point 'word)
(thing-at-point 'sentence)
(thing-at-point 'sentence t)
(thing-at-point 'sexp)</pre>

<p>
Try it on this: ~/Projects/Code/emacs-from-scratch/Emacs.org
</p>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Contents.html#Buffer-Contents">Emacs Lisp Manual: Examining Buffer Contents</a>
</p>
</div>

<h2><a id="searching-for-text" class="anchor" href="#searching-for-text">¶</a>Searching for text</h2><div class="outline-text-2" id="text-orgdfcf644">
<p>
Sometimes it can be useful to search for text inside of the buffer and move the point to where the match was found.  You can use the <code>search-forward</code> and <code>search-backward</code> functions for this:
</p>

<pre>(search-forward <span class="org-string">"ways"</span>)
(search-backward <span class="org-string">"I just searched myself"</span>)
(search-backward <span class="org-string">"inside"</span> nil t 1)
(search-backward <span class="org-string">"inside"</span> nil t 3)</pre>

<p>
Keep in mind that <code>search-forward</code> will put the point <b>after</b> the match and <code>search-backward</code> will put the point <b>before</b> the match!
</p>

<p>
The other parameters can be useful too:
</p>

<ul class="org-ul">
<li><code>bound</code> (param 2) - A pair (cons) of positions restricting the search within those two positions</li>
<li><code>noerror</code> - If <code>t</code>, don&rsquo;t signal an error when no match is found</li>
<li><code>count</code> - Find the &ldquo;nth&rdquo; result where <code>count</code> is <code>n</code></li>
</ul>

<p>
There are other ways to search inside of buffers, including the use of regular expressions to extract text from matches.  We&rsquo;ll cover this in another episode!
</p>
</div>

<h2><a id="example-finding-org-code-block-output-paths" class="anchor" href="#example-finding-org-code-block-output-paths">¶</a>Example: Finding Org code block output paths</h2><div class="outline-text-2" id="text-orgd479ec1">
<p>
Now we can finally do something useful in our code!  Let&rsquo;s write some Emacs Lisp to search for <code>:tangle</code> properties on Org source blocks so that we can extract the file path:
</p>

<pre>(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--scan-for-output-files</span> (org-file)
  (<span class="org-keyword">let</span> ((output-files '())
        (current-match t))
    (<span class="org-keyword">with-current-buffer</span> (<span class="org-keyword">or</span> (get-file-buffer org-file)
                             (find-file-noselect org-file))
      (<span class="org-keyword">save-excursion</span>
        (goto-char (point-min))  <span class="org-comment-delimiter">;; </span><span class="org-comment">Or (beginning-of-buffer)</span>
        (<span class="org-keyword">while</span> current-match
          (<span class="org-keyword">setq</span> current-match (search-forward <span class="org-string">":tangle "</span> nil t))
          (<span class="org-keyword">when</span> current-match
            (<span class="org-keyword">let</span> ((output-file (thing-at-point 'filename t)))
              <span class="org-comment-delimiter">;; </span><span class="org-comment">If a file path was found, add it to the list</span>
              (<span class="org-keyword">unless</span> (<span class="org-keyword">or</span> (not output-file)
                          (string-equal output-file <span class="org-string">"no"</span>))
                (<span class="org-keyword">setq</span> output-files (cons output-file
                                         output-files))))))))
    output-files))

(<span class="org-keyword">let</span> ((output-files '()))
  (<span class="org-keyword">dolist</span> (org-file dotcrafter-org-files)
    (<span class="org-keyword">setq</span> output-files
          (append output-files
                  (dotcrafter--scan-for-output-files
                   (expand-file-name org-file
                                     dotcrafter-dotfiles-folder)))))

  output-files)</pre>
</div>

<h2><a id="inserting-text" class="anchor" href="#inserting-text">¶</a>Inserting text</h2><div class="outline-text-2" id="text-org135aabe">
<p>
You can insert text into the buffer at the current point using the <code>insert</code> and <code>insert-char</code> functions.  <code>insert</code> will insert the arbitrary list of strings or characters at point and <code>insert-char</code> will insert the specified character with an optional repeat count:
</p>

<pre>(insert <span class="org-string">"  0_o"</span>)
(insert <span class="org-string">"\n"</span> <span class="org-string">"This is"</span> ?\s ?\n <span class="org-string">"Sparta!"</span>)

(insert-char ?\- 20)</pre>

<p>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Insertion.html#Insertion">Emacs Lisp Manual: Inserting Text</a>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">Emacs Lisp Manual: Basic Char Syntax</a>
</p>
</div>

<h2><a id="example-updating-the-gitignore-file" class="anchor" href="#example-updating-the-gitignore-file">¶</a>Example: Updating the .gitignore file</h2><div class="outline-text-2" id="text-org7772c22">
<pre>(<span class="org-keyword">defvar</span> <span class="org-variable-name">dotcrafter-gitignore-marker</span> <span class="org-string">"\n# -- Generated by dotcrafter.el! --\n\n"</span>
  <span class="org-doc">"The marker string to be placed in the .gitignore file of the</span>
<span class="org-doc">dotfiles repo to indicate where the auto-generated list of ignored</span>
<span class="org-doc">files begins."</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--update-gitignore</span> ()
  (<span class="org-keyword">let</span> ((output-files '()))
    (<span class="org-keyword">dolist</span> (org-file dotcrafter-org-files)
      (<span class="org-keyword">setq</span> output-files
            (append output-files
                    (dotcrafter--scan-for-output-files
                     (expand-file-name org-file
                                       dotcrafter-dotfiles-folder)))))

    (<span class="org-keyword">let</span> ((gitignore-file (expand-file-name <span class="org-string">".gitignore"</span>
                                            dotcrafter-dotfiles-folder)))
      (<span class="org-keyword">with-current-buffer</span> (<span class="org-keyword">or</span> (get-file-buffer gitignore-file)
                               (find-file-noselect gitignore-file))
        (<span class="org-keyword">save-excursion</span>
          (beginning-of-buffer)
          (<span class="org-keyword">or</span> (<span class="org-keyword">progn</span>
                (search-forward dotcrafter-gitignore-marker nil t))
              (<span class="org-keyword">progn</span>
                (end-of-buffer)
                (insert <span class="org-string">"\n"</span> dotcrafter-gitignore-marker)))

          (<span class="org-keyword">dolist</span> (output-file output-files)
            (insert output-file <span class="org-string">"\n"</span>)))))))</pre>

<p>
Notice that running this multiple times appends the list again and again!  We need to delete the old list before adding the new one.
</p>
</div>

<h2><a id="deleting-text" class="anchor" href="#deleting-text">¶</a>Deleting text</h2><div class="outline-text-2" id="text-org0794314">
<p>
You can delete a region of text in a buffer using the <code>delete-region</code> function.  It takes two parameters, the <code>start</code> point and the <code>end</code> point.
</p>

<pre>(<span class="org-keyword">with-current-buffer</span> <span class="org-string">".gitignore"</span>
  (delete-region (point) (point-max)))</pre>
</div>

<h2><a id="saving-a-buffer" class="anchor" href="#saving-a-buffer">¶</a>Saving a buffer</h2><div class="outline-text-2" id="text-org8f86e89">
<p>
To save the contents of a buffer back to the file it is associated with, you can use the <code>save-buffer</code> function:
</p>

<pre>(save-buffer)</pre>
</div>

<h2><a id="example-cleaning-up-and-saving-the-gitignore-file" class="anchor" href="#example-cleaning-up-and-saving-the-gitignore-file">¶</a>Example: Cleaning up and saving the .gitignore file</h2><div class="outline-text-2" id="text-org587da5d">
<p>
Let&rsquo;s finish the job of automatically managing the <code>.gitignore</code> file by cleaning up its contents and saving it:
</p>

<pre>(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--update-gitignore</span> ()
  (<span class="org-keyword">let</span> ((output-files '()))
    (<span class="org-keyword">dolist</span> (org-file dotcrafter-org-files)
      (<span class="org-keyword">setq</span> output-files
            (append output-files
                    (dotcrafter--scan-for-output-files
                     (expand-file-name org-file
                                       dotcrafter-dotfiles-folder)))))

    (<span class="org-keyword">let</span> ((gitignore-file (expand-file-name <span class="org-string">".gitignore"</span>
                                            dotcrafter-dotfiles-folder)))
      (<span class="org-keyword">with-current-buffer</span> (<span class="org-keyword">or</span> (get-file-buffer gitignore-file)
                               (find-file-noselect gitignore-file))
        (<span class="org-keyword">save-excursion</span>
          (beginning-of-buffer)
          (<span class="org-keyword">or</span> (<span class="org-keyword">progn</span>
                (search-forward dotcrafter-gitignore-marker nil t))
              (<span class="org-keyword">progn</span>
                (end-of-buffer)
                (insert <span class="org-string">"\n"</span> dotcrafter-gitignore-marker)))

          (delete-region (point) (point-max))
          (<span class="org-keyword">dolist</span> (output-file output-files)
            (insert output-file <span class="org-string">"\n"</span>))

          (save-buffer))))))</pre>
</div>

<h2><a id="whatrsquos-next" class="anchor" href="#whatrsquos-next">¶</a>What&rsquo;s next?</h2><div class="outline-text-2" id="text-org3cecbc9">
<p>
In the next episode, we&rsquo;ll cover how to manage files and directories in Emacs Lisp.  We&rsquo;ll also extend <code>dotcrafter</code> to create symbolic links to their target locations in the home directory!
</p>
</div>

<h2><a id="final-code" class="anchor" href="#final-code">¶</a>Final Code</h2><div class="outline-text-2" id="text-org76a202d">
<p>
You can check out the final code <a href="https://github.com/daviwil/dotcrafter.el/blob/8d507eda31e08a789c38a5d729866eb4cda6abaf/dotcrafter.el">here</a> at the <code>dotcrafter.el</code> repository!
</p>

<p>
I&rsquo;ve also included the code below for posterity:
</p>

<pre>(<span class="org-keyword">defvar</span> <span class="org-variable-name">dotcrafter-gitignore-marker</span> <span class="org-string">"\n# -- Generated by dotcrafter.el! --\n\n"</span>
  <span class="org-doc">"The marker string to be placed in the .gitignore file of the</span>
<span class="org-doc">dotfiles repo to indicate where the auto-generated list of ignored</span>
<span class="org-doc">files begins."</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--scan-for-output-files</span> (org-file)
  (<span class="org-keyword">let</span> ((output-files '())
        (current-match t))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Get a buffer for the file, either one that is</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">already open or open a new one</span>
    (<span class="org-keyword">with-current-buffer</span> (<span class="org-keyword">or</span> (get-file-buffer org-file)
                             (find-file-noselect org-file))
      <span class="org-comment-delimiter">;; </span><span class="org-comment">Save the current buffer position</span>
      (<span class="org-keyword">save-excursion</span>
        <span class="org-comment-delimiter">;; </span><span class="org-comment">Go back to the beginning of the buffer</span>
        (goto-char (point-min))

        <span class="org-comment-delimiter">;; </span><span class="org-comment">Loop until no more matches are found</span>
        (<span class="org-keyword">while</span> current-match
          <span class="org-comment-delimiter">;; </span><span class="org-comment">Search for blocks with a :tangle property</span>
          (<span class="org-keyword">setq</span> current-match (search-forward <span class="org-string">":tangle "</span> nil t))
          (<span class="org-keyword">when</span> current-match
            (<span class="org-keyword">let</span> ((output-file (thing-at-point 'filename t)))
              <span class="org-comment-delimiter">;; </span><span class="org-comment">If a file path was found, add it to the list</span>
              (<span class="org-keyword">unless</span> (<span class="org-keyword">or</span> (not output-file)
                          (string-equal output-file <span class="org-string">"no"</span>))
                (<span class="org-keyword">setq</span> output-files (cons output-file
                                         output-files))))))))
    output-files))

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--update-gitignore</span> ()
  (<span class="org-keyword">let</span> ((output-files '()))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Gather the list of output files from all Org files</span>
    (<span class="org-keyword">dolist</span> (org-file dotcrafter-org-files)
      (<span class="org-keyword">setq</span> output-files
            (append output-files
                    (dotcrafter--scan-for-output-files
                     (expand-file-name org-file dotcrafter-dotfiles-folder)))))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">Now that we have the output files, update the .gitignore file</span>
    (<span class="org-keyword">let</span> ((gitignore-file (expand-file-name <span class="org-string">".gitignore"</span>
                                            dotcrafter-dotfiles-folder)))
      <span class="org-comment-delimiter">;; </span><span class="org-comment">Find the .gitignore buffer and prepare for editing</span>
      (<span class="org-keyword">with-current-buffer</span> (<span class="org-keyword">or</span> (get-file-buffer gitignore-file)
                               (find-file-noselect gitignore-file))
        (<span class="org-keyword">save-excursion</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">Find or insert the dotcrafter-gitignore-marker</span>
          (beginning-of-buffer)
          (<span class="org-keyword">or</span> (<span class="org-keyword">progn</span>
                (search-forward dotcrafter-gitignore-marker nil t))
              (<span class="org-keyword">progn</span>
                (end-of-buffer)
                (insert <span class="org-string">"\n"</span> dotcrafter-gitignore-marker)))

          <span class="org-comment-delimiter">;; </span><span class="org-comment">Delete the rest of the buffer after the marker</span>
          (delete-region (point) (point-max))

          <span class="org-comment-delimiter">;; </span><span class="org-comment">Insert a line for each output file</span>
          (<span class="org-keyword">dolist</span> (output-file output-files)
            (insert output-file <span class="org-string">"\n"</span>))

          <span class="org-comment-delimiter">;; </span><span class="org-comment">Make sure the buffer is saved</span>
          (save-buffer))))))</pre>
</div>
</div></div><div class="list-form center"><div class="list-form-title">Subscribe to the System Crafters Newsletter!</div><form method="POST" action="https://www.simplelists.com/subscribe.php"><input type="hidden" name="format" value="text"/><input type="hidden" name="action" value="subscribe"/><input type="hidden" name="list" value="news@lists.systemcrafters.net"/><div class="list-form-message">Stay up to date with the latest System Crafters news and updates!  Read the <a href="/newsletter/">Newsletter</a> page for more information.</div><div class="row"><div class="column"><div class="row center list-form-label">Name (optional)</div><div class="row"><input type="text" name="name"/></div></div><div class="column"><div class="row center list-form-label">Email Address</div><div class="row"><input type="text" name="email"/></div></div></div><div><input type="submit" value="Subscribe!"/></div></form></div></div><footer class="site-footer"><div class="container"><div class="row"><div class="column"><p><a href="https://weavermarquez.github.io/privacy-policy/">Privacy Policy</a> · <a href="https://weavermarquez.github.io/credits/">Credits</a> · <a href="https://weavermarquez.github.io/rss/">RSS Feeds</a> · <a rel="me" href="https://fosstodon.org/@daviwil">Fediverse</a></p><p>© 2021-2023 System Crafters LLC, and also Weaver Ripped this off</p></div><div class="column align-right"><p><a href="https://github.com/weavermarquez/weavermarquez.github.io"><img src="https://weavermarquez.github.io/img/codeberg.png" style="width: 120px" alt="Contribute on Codeberg"/></a></p></div></div></div></footer></body></html>
